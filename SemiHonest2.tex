\newcommand{\idealMSLE}{\mathcal{F}_{\text{MSLE}}}
\newcommand{\idealStreamSample}{\mathcal{F}_{\text{SAMPLE}}}
\newcommand{\hybrid}[1]{\mathrm{\textbf{Hyb}}_{#1}}
\newcommand{\eid}{{eid}}
\newcommand{\init}{\texttt{initialize}}
\newcommand{\register}{\texttt{register}}
\newcommand{\elect}{\texttt{elect}(\eid)}
\newcommand{\reveal}{\texttt{reveal}(\eid, \ell)}
\newcommand{\extractMin}{\texttt{ExtractMin}}
\newcommand{\getMin}{\texttt{GetMin}}
\newcommand{\ct}{\texttt{ct}}

\newcommand{\PQInsert}{\texttt{PQ.Insert}}
\newcommand{\PQExtract}{\texttt{PQ.ExtractFront}}
\newcommand{\PQFront}{\texttt{PQ.Front}}
\newcommand{\PQ}{\texttt{PQ}}

\newcommand{\EncPQInsert}{\texttt{EncPQ.Insert}}
\newcommand{\EncPQExtract}{\texttt{EncPQ.ExtractFront}}
\newcommand{\EncPQFront}{\texttt{EncPQ.Front}}


\newcommand{\EncPQ}{\texttt{EncPQ}}

\section{Data Independent Streaming Sampler}
\label{sec:streaming_sampler}
Our construction makes heavy use of a data independent streaming sampler which we will define below.
The streaming sampler relies on a data independent priority queue and in turn makes use of \LS{Cite Shi} protocol for an oblivious priority queue.

\subsection*{
	Encrypted Data Independent Queue
}
In this work, we will data independent queues as studied in \cite{toft2011secure, mitchell2014data, mazloom2023efficient}.
Data independent data structures are unique as their control flow and memory access do not depend on input data (\cite{mitchell2014data}).

They are especially useful as they allow for efficient computation within FHE as control flow is not dependent
on underlying ciphertexts. We use a data independent queue as outlined in \cite{mazloom2023efficient}
which allows for
\begin{itemize}
	\item $\PQInsert$: Inserts a tag and value, $(p, x)$ into $\PQ$ according to the tag's priority.
	\item $\PQExtract$: Removes and returns the $(p, y)$ with highest tag priority.
	\item $\PQFront$: Returns the $(p, y)$ with highest tag priority without removing the element.
\end{itemize}
Moreover, we note that the order is stable. I.e.\ the first inserted among equal tagged elements has a higher priority.

We will use the data independent queue within public key threshold FHE such that we now have an encrypted priority queue, $\EncPQ$
with functionality
\begin{itemize}
	\item $\EncPQInsert$: Inserts a tag and value, $\Enc(p, x)$ into $\PQ$ according to the tag's priority.
	\item $\EncPQExtract$: Removes and returns the $\Enc(p, y)$ with highest tag priority.
	\item $\EncPQFront$: Returns the $\Enc(p, y)$ with highest tag priority without removing the element.
\end{itemize}

We further require that for $\Enc(p, y) \gets \EncPQExtract$ (and $\EncPQFront$) and $x_1, ..., x_n$ drawn from a random distribution,
\begin{align}
	\label{eq:gameEncPQ}
	\Bigl\lvert \Pr[\advers\left(x_1, \dots x_n, \Enc(p_1, x_1), ..., \Enc(p_n, x_n), \Enc(p, y), i\right) = 1] \\
	 	 - \Pr[\advers\left(x_1, \dots x_n, \Enc(p_1, x_1), ..., \Enc(p_n, x_n), \Enc(p, y), j\right) = 1]
		 \Bigr\rvert \leq \negl(\lambda) \notag
\end{align}
where $(p_i, x_i)$ and $(p_j, x_j)$ are the $i$th and $j$th submitted message to the priority queue for $i \neq j$.

\begin{lemma}
	Assuming the indistinguishablity of TFHE cipher texts, $\Enc(m_1) \dots \Enc(m_n)$
	where $m_i \neq m_j$ for $i \neq j$ and are known to the adversary, then \cref{eq:gameEncPQ} holds.

	\begin{proof}
		Assume towards contradiction that there exists an adversary $\advers$ which can distinguish between a random 
		message to the priority queue and the output of $\EncPQExtract$ (resp. $\EncPQFront$).
		Then, we can construct an adversary $\advers'$ which can distinguish TFHE cipher text, $\ct_1 = \Enc(m_1), \dots, \ct_n = \Enc(m_n)$, as follows:
		\begin{enumerate}
			\item $\advers'$ simulates an encrypted priority queue, $\EncPQ$.
			\item $\advers'$ inserts $x_i = \Enc(\ct_i, r_i)$ into $\EncPQ$ for all $i \in [n]$.
			\item The adversary then calls $\Enc(p, y) \gets \EncPQExtract$ (resp. $\EncPQFront$) and uses $\advers$ to distinguish between $x_1, \dots x_n$.
			\item Output $m_i$ where $\Enc(p, y) = x_i$.
		\end{enumerate}
		Clearly, if the adversary can distinguish the priority queue outcomes, then using $\advers$, he can with non-negligible probability
		distinguish encryptions of $m_1, \dots, m_n$ as the relative ordering of the encryptions is preserved and thus the priority queue repeatably gives the same output.
	\end{proof}
\end{lemma}


\subsection*{Encrypted Streaming Sampler}
A streaming sampler should output a random subset of size $k$ from a stream of $n$ elements with a random ordering.
We can build a streaming sampler from a priority queue as follows:


\begin{algorithm}
	\caption{Encrypted Gated Insert}
	\label{alg:EncIns}
	\begin{algorithmic}
		\Require $\Enc(\text{coin}), \EncPQ, \ct_a$
		\Ensure $\EncPQ$'
		\State $\ct_b \gets \EncPQExtract(\PQ)$
		\State $\ct_{\text{new}} = \Enc(\text{coin}) \cdot \ct_a + (\Enc(\text{coin}) - 1) \cdot \ct_b$
		\State $\EncPQInsert(ct_{\text{new}})$
		\State \Return $\EncPQ$
	\end{algorithmic}
\end{algorithm}

We will use a slightly modified version of a streaming sampler where randomness is submitted alongside the message.
We can then implement the algorithm as follows
\begin{itemize}
	\item $\texttt{Insert}(\ct_i, \Enc(e_i))$ where $\ct_i$ is a cipher text and $\Enc(e_i)$ is encrypted randomness
	\begin{itemize}
		\item If the item is the $m$-th item and $m \leq k$, insert the item into the queue along with $e_i$ as its tag via $\EncPQInsert(\Enc(e_i), \ct)$.
		\item If $m > k$, we will evaluate the PRF (in FHE) to get an encoded random coin which is 1 with probability $1/m$ and 0 otherwise.
		Then, run \cref{alg:EncIns} which will
		\begin{itemize}
			\item replace the smallest labeled item in the queue with the new item if the coin is 1.
			\item not replace the smallest item in the queue if the coin is 0.
		\end{itemize}
	\end{itemize}

	\item At the end of the stream, we output all the items in the priority queue, $\ct_{a_1} ... \ct_{a_k}$ in order
	 by repeatably calling $\EncPQExtract$.
	
\end{itemize}

We can formalize soundness as a game as follows, for all $\ell \in [k], i, j \in [n]$,
\begin{align}
	\Bigl\lvert 
		\Pr[\advers(\ct_1, \dots, \ct_n, e_1, \dots, e_n, \ct_{a_1}, \dots, \ct_{a_k}, \ell, i) = 1] \\
		 - \Pr[\advers(\ct_1, \dots, e_1, \dots, \ct_{a_1}, \dots, \ell, j) = 1]
	\Bigr\rvert \leq \negl(\lambda) \notag
\end{align}
In words, the adversary should not be able to guess with any advantage which of the $\ell$-th 
outputted cipher text is associated with which inputted cipher text.

\begin{lemma}
	Our construction of a streaming sampler is sound.
	\begin{proof}
		By construction of the streaming sampler, we have that $\Pr[a_\ell = i] = 1/n$ and thus $\Pr[\Dec(\ct_{a_\ell}) = \Dec(\ct_i)] = 1/n$.
		% Now, we need to show that the adversary cannot distinguish between the output of the streaming sampler and a random subset of size $k$.
		...


		% TODO: this should not be too bad
		% Hmmm.... all randomness (add coins) could be input into the protocol, thus its repeatable?
	\end{proof}
\end{lemma}

\section{MSLE Protocol}
\label{sec:msle_protocol}
We use a similar notion of ideal functionality for a multi-secret leader election from the ideal
functionality of single secret leader election of \LS{CITE}.

\begin{figure}[ht]
	\centering
	\fbox{
		\begin{minipage}{1\textwidth}
			\textbf{The MSLE functionality} $\idealMSLE$:
			Initialize $E, R \gets \emptyset, \gets 0$. Fix some $k \in \N$ to denote the number of rounds. Upon receiving,
			\begin{itemize}
				\item $\register$ from party $P_i$, set $R \gets R \cup \{(i, n\}$, broadcast $(\texttt{register}, i)$ to all parties and set $n \gets n + 1$
				\item $\elect$ $k$ leaders from all honest parties. If $|R| \geq k$ and $\eid$ was not requested before,
				      randomly sample $W^{\eid} \subseteq R$ where $|W^{\eid}| = k$.
				      Then, assign a random ordering to $W^\eid$ to get ordered set $E^\eid$.
				      Next, send $(\texttt{outcome}, \eid, a)$ to $P_j$ for all $E^\eid_a = (j, \cdot)$
				      and $(\texttt{outcome}, \eid, \bot)$ to $P_i$ if $(i, \cdot) \notin E^\eid$. Store $E \gets E \bigcup \{E^\eid\}$.
				\item $\reveal$ from $P_i$: for $E_\eid \in E$, if $i = E^\eid_a$, broadcast $(\texttt{result}, \eid, \ell, i)$.
				      Otherwise, broadcast $(\texttt{rejected}, \eid, \ell, i)$.
			\end{itemize}
		\end{minipage}
	}
	\caption{Description of the MSLE functionality, heavily based on the description of SSLE in \LS{CITE Dario and CFG21}}.
	\label{fig:my_label}
\end{figure}

\begin{figure}
	\centering
	\fbox{
		\begin{minipage}{1\textwidth}
			\textbf{The MSLE Protocol} $\pi_{\text{MSLE}}$:
			Initialize $n = 0$. Fix some $k \in \N$ to denote the number of rounds.
			Also, sample ;
			this will be the key FHE to the PRF.

			\begin{itemize}
				\item $\init$
				\begin{itemize}
					\item Set $n = 0$
					\item Sample some secret $s_{\texttt{TFHE}}$ and publicly publicly publish $\Enc(s_{\texttt{TFHE}})$.
					This will be the key to the PRF
					\item Initialize an empty set $C$, containing all party's registered commitments.
				\end{itemize}

				\item $\register(\Enc(c_i))$ from $P_i$ where $c_i = \comm(s_i, r_i)$ for secret $s_i$ and secret randomness $r_i$,
				\begin{itemize}
					\item If party $P$ does not already have a TFHE share, create a TFHE share for $P_i$.
					\item Add $\Enc(c_i)$ to $C$.
					\item $n \gets n + 1$
				\end{itemize}
				\item $\elect$ $k$  
					\begin{itemize}
						\item An encrypted streaming sampler will be publicly initialized
						\item Public randomness, $r$ will be sampled to and used in the encrypted PRF to get random $\Enc(e_1), ..., \Enc(e_n)= \Enc(\texttt{PRF}(r, s_\texttt{TFHE}))$
						\item All $c_i \in C$ will be fed to the encrypted streaming sampler along with randomness $\Enc(e_i)$ 
						\item The encrypted streaming sampler will output a list of $k$ messages: $\Enc(c_{a_1}), \Enc(c_{a_2}), ..., \Enc(c_{a_k})$.
						\item Then, at least $t$ parties will submit decryption shares to get $c_{a_1}, ..., c_{a_k}$.
						\item Each party will then check if they won an election by seeing if their commitment is in the list of decrypted messages.
					\end{itemize}
				\item $\texttt{reveal}(\eid, \ell, \Enc(c'_i))$ from $P_i$
					\begin{itemize}
						\item $P_i$ submits a zero knowledge proof that they know the opening to $c_{a_\ell}$. If this proof verifies,
						remove $\Enc(c_i)$ from $C$ and add $\Enc(c'_i)$. Then send out $(\texttt{result}, \eid, \ell, i)$ to all parties.
						Otherwise, send out $(\texttt{rejected}, \eid, \ell, i)$ to all parties.
					\end{itemize}
			\end{itemize}
		\end{minipage}
	}
	\caption{Description of the MSLE protocol}
	\label{fig:protocolMSLE}
\end{figure}

\subsection{Simulation Security}
To show simulation security, we will prove that, given a party's input and output in the ideal model,
a simulator can simulate the distribution of the view in the protocol for the party. Note that because the
protocol is deterministic, it suffices to prove simulation for only the party's output.

More formally we will show that for party $i$,
\begin{equation}
	\label{eq:simSecReg}
	\simulator_i\left(s_i, r_i, \idealMSLE.\register_i\right) \compInd \texttt{view}_{\register_i}((s_0, r_0), ..., (s_n, r_n)),
\end{equation}
\begin{equation}
	\label{eq:simSecElect}
	\simulator_i\left(s_i, b_i, r_i, \idealMSLE.\elect_i\right) \compInd \texttt{view}_{\elect_i}((s_0, b_0), ..., (s_n, b_n)),
\end{equation}
and
\begin{equation}
	\label{eq:simSecReveal}
	\simulator_i\left(b_{a, 1}, \dots, b_{a, k}, s_i, r_i, \idealMSLE.\reveal_i\right) \compInd \texttt{view}_{\reveal_i}(),
\end{equation}

\begin{lemma}
	We will first show that \cref{eq:simSecReg} is simulation secure.
	\begin{proof}
		The view of each party $i$ for $\register$ can be expressed as
		\begin{equation*}
			(r_i, s_i, c_i, C, \Enc(c_i), n)
		\end{equation*}
		We can create a simulator $\simulator_i$ that takes as input $s_i, r_i, n$ and outputs
		an indistinguishable view 
		\begin{enumerate}
			\item Sample something? Does the simulator have access to C?
		\end{enumerate}
	\end{proof}
\end{lemma}


\begin{lemma}
	We will now show that \cref{eq:simSecElect} is simulation secure.
	\begin{proof}
		The view of each party $i$ for $\elect$ can be expressed as
		\begin{align*}
			(r_i,  s_i, \Enc(b_{1}), \dots \Enc(b_n), \Enc(r'_1), \dots, \Enc(r'_n), \\
				\Enc(b_{a_1}), \dots, \Enc(b_{a_k}), \sigma_1, \dots \sigma_t, b_1, \dots, b_n, y)
		\end{align*}
		where $r'_i$ is the randomness from the streaming sampler, $\sigma_1, \dots \sigma_t$ are the decryption shares,
		and $y \in \set{\bot, 1, ..., k}$ representing whether a party won election $1$ through $k$ or not ($\bot$).
		Then, we have the simulator proceed in the following manner:
		\begin{enumerate}
			\item The simulator sets a random, local tape
			% TODO: question, are these c_js part of the protocol/ commitment or is it valid to do these samples?
			% (I.e. they are not messages)...
			\item The simulator samples $c'_j$ for all $j \neq i$ where $c'_j$ is a commitment to a random value
			\item The simulator samples some randomness $r$ and computes $\Enc(e_1), \dots, \Enc(e_n) = \Enc(\texttt{PRF}(r, s_\texttt{TFHE}))$
			\item The simulator creates an encrypted priority queue $\EncPQ$ and simulates the encrypted streaming sampler for all inputs $\Enc(c'_j)$ for $j \in [i]$.
			\item The simulator runs the encrypted streaming sampler to get the outputs $\Enc(c'_{a_1}),... \Enc(c'_{a_k})$.
			\item The simulator then chooses a random, ordered subset $S \subseteq [n]$ where $|S| = k$. 
			If there is some $w$ such that $S_w = i$, then set $y' = w$. Otherwise, set $y' = \bot$.
			\item The simulator then sets the decryptions of $\Enc(c'_{a_\ell})$ to $c'_{S_\ell}$.
			The simulator also creates shares $\sigma_j$ such that $\Enc(c'_{a_\ell})$ decrypts to $c'_{S_\ell}$.
			\item The simulator then outputs $y'$
			
		\end{enumerate}
		We now use a sequence of hybrids to show that the view of the real protocol is indistinguishable from
		that of the simulated one
		\begin{itemize}
			\item $\hybrid{0}$: The real protocol
			\item $\hybrid{1}$: As $\hybrid{0}$ but, for all $j \neq i$, $\Enc(c_j)$ are replaced with $\Enc(c'_j)$, where $c'_j$ is a commitment to a random value.
			We can see that $\hybrid{0} \equiv \hybrid{1}$ by the hiding property of commitments.
			\item $\hybrid{2}$: As $\hybrid{1}$ but replace $\Enc(c_{a_1}),... \Enc(c_{a_k})$ with
			$\Enc(c'_{a_1}),... \Enc(c'_{a_k})$, the output of sampling the encrypted streaming sampler with $\Enc(c'_j)$.
			\item $\hybrid{3}$: As $\hybrid{2}$ but replace $\Dec(\Enc(c'_{a_1})),... \Dec(\Enc(c'_{a_k}))$ with
			$c'_{S_1},... c'_{S_k}$, where $S$ is the random subset chosen by the simulator.
			Replace $\sigma_j$ with shares $\sigma'_j$ such that $\Enc(c'_{a_\ell})$ decrypts to $c'_{S_\ell}$.
			\item $\hybrid{4}$: As $\hybrid{3}$ but replace $y$ with $y'$.
		
		% 	% TODO: better define threshold decryption as separate thing
		% 	% TODO: remove separate ticket registration
			\item $\hybrid{5}$: The simulated protocol
		\end{itemize}
		% TODO: can I have proof be within bullet points
			% Question: can a simulator have access to information from prior calls? 
			% Ohhhhhhhhhhhhhhhh... I see output $y$ has to follow distribution as well.


	\end{proof}
\end{lemma}

\begin{lemma}
	We will now show that \cref{eq:simSecReveal} is simulation secure.
	\begin{proof}

	\end{proof}
\end{lemma}

