\newcommand{\idealMSLE}{\mathcal{F}_{\text{MSLE}}}
\newcommand{\idealStreamSample}{\mathcal{F}_{\text{SAMPLE}}}
\newcommand{\eid}{{eid}}
\newcommand{\register}{\texttt{register}}
\newcommand{\elect}{\texttt{elect}(\eid)}
\newcommand{\reveal}{\texttt{reveal}(\eid, a)}

\section{Data Independent Streaming Sampler}
\label{sec:streaming_sampler}
Our construction makes heavy use of a data independent streaming sampler which we will define below.
The streaming sampler relies on a data independent priority queue and in turn makes use of \LS{Cite Shi} protocol for an oblivious priority queue.

\subsection*{Data Independent Queue Ideal Functionality}

\begin{figure}[ht]
	\centering
	\fbox{
		\begin{minipage}{1\textwidth}
			\textbf{Encrypted Data Independent Queue Ideal Functionality} $\idealMSLE$:
			Initialize $L$ to be an empty list
			\begin{itemize}
				\item $\texttt{Insert}(\Enc(p), \Enc(x))$ upon receiving $(\Enc(p), \Enc(x))$, place $(\Enc(p), \Enc(x))$
				into an initially empty list $L$ and broadcast $(\Enc(p), \Enc(x))$ to all parties as well as termination of insert.
				\item $y \gets \texttt{ExtractMin}()$ Delete $(\Enc(p), \Enc(x))$ with the lowest $p$ value.
				Then, set $y$ to be a re-encryption of $x$ such that $y$ is indistinguishable from all other elements in $L$.

				\item $y \gets \texttt{GetMin}()$ Get $(\Enc(p), \Enc(x))$ with the lowest $p$ value.
				Then, set $y$ to be a re-encryption of $x$ such that the encryption of $x$ and $y$ are indistinguishable.
			\end{itemize}
		\end{minipage}
	}
	\caption{Description of the MSLE functionality, heavily based on the description of SSLE in \LS{CITE Dario and CFG21}}.
	\label{fig:dataIndepQ}
\end{figure}
% https://eprint.iacr.org/2011/081.pdf
% See page 8, extend 

\subsection*{Streaming Sampler Ideal Functionality}
The ideal functionality of a data independent sampler is given by $\idealStreamSample$ (TODO: cite Elaine)
which outputs a random subset of size $k$ from a stream $S$ with a random ordering.

\begin{figure}[ht]
	\centering
	\fbox{
		\begin{minipage}{1\textwidth}
			\textbf{Encrypted Data Independent Streaming Sampler Ideal Functionality} $\idealMSLE$:
			Initialize $L$ to be an empty list
			\begin{itemize}
				\item $\texttt{Insert}(\Enc(x))$ upon receiving $\Enc(x)$, place $\Enc(x)$
				into an initially empty list $L$ 
				\item $S \gets \texttt{Sample}()$ Randomly sample an ordered and re-encrypted subset $S \subseteq L$ such that $|S| = k$, $S$ has a random ordering
				and $S_a$ is indistinguishable from all elements in $L$.
			\end{itemize}
		\end{minipage}
	}
	\caption{Description of ideal sampling functionality}.
	\label{fig:samplerIdeal}
\end{figure}
%

\subsection*{Protocol for Streaming Sampler}
This protocol is identical to that of (TODO: cite Elaine) except that the 
we replace the oblivious queue with the stronger notion of a data independent queue and public coin randomness
with randomness generated within a PRF.

\section{MSLE Protocol}
\label{sec:msle_protocol}
We use a similar notion of ideal functionality for a multi-secret leader election from the ideal
functionality of single secret leader election of \LS{CITE}.

\begin{figure}[ht]
	\centering
	\fbox{
		\begin{minipage}{1\textwidth}
			\textbf{The MSLE functionality} $\idealMSLE$:
			Initialize $E, R \gets \emptyset, \gets 0$. Fix some $k \in \N$ to denote the number of rounds. Upon receiving,
			\begin{itemize}
				\item $\register$ from party $P_i$, set $R \gets R \cup \{(i, n)\}$, broadcast $(\texttt{register}, i)$ to all parties and set $n \gets n + 1$
				\item $\elect$ $k$ leaders from all honest parties. If $|R| \geq k$ and $\eid$ was not requested before,
				randomly sample $W^{\eid} \subseteq R$ where $|W^{\eid}| = k$.
				Then, assign a random ordering to $W^\eid$ to get ordered set $E^\eid$.
				Next, send $(\texttt{outcome}, \eid, a)$ to $P_j$ for all $E^\eid_a = (j, \cdot)$
				and $(\texttt{outcome}, \eid, \bot)$ to $P_i$ if $(i, \cdot) \notin E^\eid$. Store $E \gets E \bigcup \{E^\eid\}$.
				\item $\reveal$ from $P_i$: for $E_\eid \in E$, if $i = E^\eid_a$, broadcast $(\texttt{result}, \eid, a, i)$.
				Otherwise, broadcast $(\texttt{rejected}, \eid, a, i)$.
			\end{itemize}
		\end{minipage}
	}
	\caption{Description of the MSLE functionality, heavily based on the description of SSLE in \LS{CITE Dario and CFG21}}.
	\label{fig:my_label}
\end{figure}

We wil realize MSLE via the following algorithm:
\begin{itemize}
	\item Each party $i$ will submit a message $\Enc(b_i)$ to the oblivious streaming sampler for some secret $b_i$ which is a commitment to a secret known only by party $i$.
	\item After all parties submitted there messages, the oblivious streaming sampler will output a list of $k$ messages: $\Enc(b_{a_1}), \Enc(b_{a_2}), ..., \Enc(b_{a_k})$.
	\item Then, at least $t$ parties will submit decryption shares to decrypt $\Enc(b_{a_1}), ..., \Enc(b_{a_k})$.
	\item Each party will then build check if they won an election by seeing if their commitment is in the list of decrypted messages.
	A party can then prove that they won an election $a$ by showing that they know the opening to $b_a$.
\end{itemize}

\subsection{Correctness}

\subsection{Simulation Security}
To show simulation security, we will prove that, given a party's input and output in the ideal model,
a simulator can simulate the distribution of the view in the protocol for the party. Note that because the 
protocol is deterministic, it suffices to prove simulation for only the party's output.

More formally we will show that for party $i$,
\begin{equation}
	\label{eq:simSecReg}
	\simulator_i\left(s_i, r_i, \idealMSLE.\register_i\right) \compInd \texttt{view}_{\register_i}((s_0, r_0), ..., (s_n, r_n)),
\end{equation}
\begin{equation}
	\label{eq:simSecElect}
	\simulator_i\left(s_i, b_i, r_i, \idealMSLE.\elect_i\right) \compInd \texttt{view}_{\elect_i}((s_0, b_0), ..., (s_n, b_n)),
\end{equation}
and
\begin{equation}
	\label{eq:simSecReveal}
	\simulator_i\left(b_{a, 1}, \dots, b_{a, k}, s_i, r_i, \idealMSLE.\reveal_i\right) \compInd \texttt{view}_{\reveal_i}(),
\end{equation}

\begin{lemma}
	We will first show that \cref{eq:simSecReg} is simulation secure.
	\begin{proof}
		
	\end{proof}
\end{lemma}


\begin{lemma}
	We will now show that \cref{eq:simSecElect} is simulation secure.
	\begin{proof}

	\end{proof}
\end{lemma}

\begin{lemma}
	We will now show that \cref{eq:simSecReveal} is simulation secure.
	\begin{proof}

	\end{proof}
\end{lemma}

