\section{Semi Honest Reservoir Sampling Based Protocol}
\label{sec:msle_protocol}
\newcommand{\resSampling}{\mathcal{R}}
We outline a semi-honest protocol in \cref{fig:protSemiHonest} for the MSLE functionality.

\begin{figure}
	\label{fig:protSemiHonest}
	\centering
	\fbox{
		\begin{minipage}{1\textwidth}
			\textbf{The MSLE Protocol} $\pi_{\text{MSLE}}$:
			Initialize $\nBids = 0$. Fix some $k \in \N$ to denote the number of rounds.
			Initialize an empty set of tickets, $R$.
			Initialize an empty lookup of sets of parties in each election, $S$.
			Initialize an empty lookup of reservoir sampling data structures $\resSampling$ and a set of finished elections $\FinElect$
			Initialize an empty lookup of election results, $E$.

			Initialize $S \gets \emptyset$ to denote the set of sets of active participants in each round.

			\begin{itemize}
				\item $\init$
				      \begin{itemize}
					      \item Set $n = 0$
					      \item Sample a random $\TFHE$ secret key, public key pair $\TFHESk, \TFHEPk$ and publish $\TFHEPk$.
					      \item Sample some secret $s_{\texttt{TFHE}}$ and publish $\Enc(s_{\texttt{TFHE}})$.
					            This will be the key to the PRF
				      \end{itemize}

				\item $\register$ from party $P_i$
				      \begin{itemize}
					      %  TODO: not within definition of TFHE, have to change up definition :((
					      %  TODO: formalize secure channel?
					      \item If party $P_i$ does not already have a TFHE share, create a TFHE share, $\TFHESk_i$, for $P_i$
					            and send the share over a secure channel to $P_i$.

					      \item $R \gets R \cup \{(i, \nBids)\}$, set $\nBids \gets \nBids + 1$.
				      \end{itemize}
				      % \item Add $\Enc(c_i)$ to $C$.
				      % \item $n \gets n + 1$

				\item $\registerElect(\eid, \Enc(c_i), w)$ from party $P_i$ where $c_i = \comm(s_i)$ for a randomly sampled secret $s_i$.
				      \begin{itemize}
					      \item If $\eid \in \FinElect$, then send $\bot$ to $P_i$ and do nothing.
					      \item If $(i, w) \in S_\eid$ or $(i, w) \notin R$, send $\bot$ and do nothing.
					      \item Otherwise, if $\resSampling_\eid \notin \resSampling$, $\resSampling_\eid \gets \ResevInit(k)$
					      \item The CRS will be used to run a PRF to get $\Enc(e_i), \Enc(\texttt{coin}_i) = \Enc(\texttt{PRF}(c_i, s_\texttt{TFHE}))$ for $i \in S$
					      \item $\Enc(c_i)$ will be fed to the encrypted streaming sampler along with randomness via
					            $\ResevInsertN{\eid}(\Enc(c_i), \Enc(e_i), \Enc(\texttt{coin}_i))$.
				      \end{itemize}

				\item $\elect(\eid)$
				      \begin{itemize}
					      \item If $\eid \in \FinElect$, then return $\bot$ and do nothing.
					      \item The encrypted streaming sampler will output a list of $k$ messages via calling $\ResevOutputN{\eid}()$ $k$ times: $\Enc(c_{a_1}), \Enc(c_{a_2}), ..., \Enc(c_{a_k})$.
					            %  TODO: formal with TFHE decryption shares
					      \item Then, at least $t$ parties will submit decryption shares, $p_i = \TFHEPartDec(\Enc(c_{a_1}), ..., \Enc(c_{a_2}))$ to get $c_{a_1}, ..., c_{a_k} = \TFHEFinDec(\{p_i\})$.
					      \item Add $E_\eid = \left\{c_{a_1}, ..., c_{a_k}\right\}$ to $E$.
				      \end{itemize}
				\item $\texttt{reveal}(\eid, \ell, \Enc(c'_i))$ from $P_i$
				      \begin{itemize}
					      %  TODO: formal with commitments...
					      \item $P_i$ submits a proof that they know the opening to $c_{a_\ell}$.
					            If this proof verifies, send out $(\texttt{result}, \eid, \ell, i)$ to all parties.
					            Otherwise, send out $(\texttt{rejected}, \eid, \ell, i)$ to all parties.
				      \end{itemize}
			\end{itemize}
		\end{minipage}
	}
	\caption{Description of the MSLE protocol}
	\label{fig:protocolMSLE}
\end{figure}


\subsection{Semi Honest Simulation Security}


We can show semi-honest simulation security by showing that the view of each party $i$ in the real protocol
can be simulated throughout the course of one election and then that this simulation can be extended for a polynomial number of elections.

\newcommand{\totalReg}{\overline{n}}
\newcommand{\totalRev}{\overline{k}}


\newcommand{\simIMSLE}{\texttt{Sim}_i}


\begin{figure}
	\centering
	\fbox{
		\begin{minipage}{1\textwidth}
			\textbf{Simulator for Threshold MSLE} $\simIMSLE$:
			Initialize $\nBids = 0$. Fix some $k \in \N$ to denote the number of rounds.
			Initialize an empty set of tickets, $R$, an empty lookup of sets of parties in each election, $S$,
			a set of finished elections $\FinElect$,
			an empty lookup of election results, $E$,
			and a set $S \gets \emptyset$ to denote the set of sets of active participants in each round.
			Moreover, set a random tape for the simulator.

			The simulator knows, input for party $P_i$, $\TFHESk_i$ and $s_i$.

			\begin{itemize}
				\item $\register$ from party $P_j$
				      \begin{itemize}
					      \item $R \gets R \cup \{(i, \nBids)\}$, set $\nBids \gets \nBids + 1$.
					            %  Can we use a different secret key here?
					      \item Simulate the secure channel communication with party $P_j$ if $i \neq j$.
					      \item Run $\register$ honestly if $i = j$ by sending $\TFHESk_i$ to $P_i$
					            % TODO: formal
				      \end{itemize}

				\item $\registerElect(\eid, w, s_i, \TFHESk_i)$ from party $P_j$.
				      \begin{itemize}
					      \item If $j \neq i$, the simulator samples a random value $s'_j$ and follows the protocol directly using $s'_\TFHE$ and $\Enc(c'_j)$ where $c'_j = \comm(s'_j)$.
					            Store $c'_j$ in a lookup table as well as its committed message.
					      \item If $j = i$, the simulator will use the commitment $c_i = \comm(s_i)$. And run $\registerElect$ as is in the protocol
				      \end{itemize}

				      % TODO: not really... we need to make sure that the wins and losses end up correct here...			

				\item $\elect(\eid, \texttt{out}, s_i, \TFHESk_i)$ where the $\texttt{out}$ is output $\bot$ or $(\texttt{outcome}, \eid, q)_i$ for all $i \in [n]$ where $q \in \set{1, ..., k, \bot}$.
				      \begin{itemize}
					      \item Let $\totalReg$ be the total number of successful calls to $\registerElect(\eid, ., .)$ before the election for $\eid$
					      \item If the output is $\bot$, return $\bot$.
					      \item Let $a'_1, ..., a'_k$ be the ordered set of parties that won the election. I.e.\ if $q_i = \ell$ then $a'_\ell = i$.
					      \item The simulator then gives $\simTFHE(C, \set{\Enc(c'_j)}_{j \in [\totalReg]}, c'_{a'_1}, ..., c'_{a'_\ell}, S, \texttt{st})$
					            to the TFHE simulator to get a list of partial decryptions, $p_1, ..., p_{t}$ where $S$ is a qualified set % TODO: CHECK CAN USE!
					            and $C$ is the reservoir sampling circuit with PRF seed $s_\TFHE$ hardcoded.
					            Note that this sets the decryption of the output of the TFHE circuit sampling to $c'_{a'_\ell}$ for $\ell \in [k]$.
					      \item Add $E_\eid = \left\{c'_{a'_1}, ..., c'_{a'_k}\right\}$ to $E$.
				      \end{itemize}
				\item $\texttt{reveal}(\eid, \ell, \Enc(c'_j))$ from $P_j$ and output $\bot$ or $(\texttt{result}, \eid, \ell, j)$.
				      \begin{itemize}
					      % TODO: faulty? oh yeah not here...
					      \item As the simulator has knowledge of the openings to all of the commitments $c'_j$ used, the simulator
					            to honestly run $\reveal(\eid, \ell, \Enc(c'_j))$ with commitment $c'_j$ and opening $s'_j$.
					      \item Note that in the semi-honest setting, the output is never $\bot$
				      \end{itemize}
			\end{itemize}
		\end{minipage}
	}
	\caption{Description of the MSLE protocol}
	\label{fig:protocolMSLE}
\end{figure}

We will now show that $\simIMSLE$ is indeed a simulator for the view of $\pi_{\text{MSLE}}$
for $\registerElect$, $\elect$, and $\reveal$.

\begin{lemma}
	[$\registerElect$ is simulation secure]
	\label{lemma:regElectSemiHonest}
	\begin{proof}
		The simulator gets as input party $i$'s secret value, $s_i$, party $i$'s $\TFHE$ share $\TFHESk_i$,
		$\eid$, and ticket number $w$. We note that if $\eid \in \FinElect$ or $(i, w) \notin R$, then the simulator can simply output $\bot$ and
		is identical to the real protocol.
		Otherwise, if party $P_i$ calls $\registerElect$, then the simulator knows the input of $P_i$ and can simulate the protocol
		honestly. If party $P_j$ call $\registerElect$ for some $j \neq i$, then the view of the protocol
		is that of $$(\Enc(c_j), \Enc(e_i, \texttt{coin}_i), \ResevInsertN{\eid}(\Enc(c_j, e_i, \texttt{coin}_i))).$$
		Note that this view is completely determined by $\Enc(c_j)$. Also, note that $c_j$ is drawn
		from a random distribution and is not in the view of the real protocol. Thus,
		by semantic security of $\TFHE$ (\cref{def:semanticSecurityTFHE}) we have that
		$\Enc(c_j) \compInd \Enc(c'_j)$ where $c'_j$ is a commitment to a random value.
	\end{proof}
\end{lemma}

\begin{lemma}[$\elect$ is simulation secure]
	\begin{proof}
		If the view of the real protocol is $\bot$ because $\eid$ was already called, then the simulator can simply output $\bot$
		and is thus identical to the real protocol.
		Otherwise, note that the view of the protocol is
		$$
			(c_{a_1}, ..., c_{a_k}, p_1, ..., p_t, \texttt{view}(C(\Enc(c_{a_1}, e_1, \texttt{coin}_1), ..., \Enc(c_{a_k}, e_k, \texttt{coin}_k) ))).
		$$
		We will now show that simulator can simulate the above view.	
		The simulator needs to ``fix'' the output of $\elect$ to yield
		a list of commitments such that, if $a'_\ell = j$ if party $j$ wins election $\ell$.
		The TFHE simulator can simply output the decryption shares, $p_1, ... p_t$ using 
		$$\simTFHE(C, \set{\Enc(c'_j, e_j, \texttt{coin}_j)}_{j \in [\totalReg]}, c'_1, ..., c'_{a_\ell}, S, \texttt{st}).$$
		Note that the reservoir sampling circuit is indeed simulated by $\simTFHE$
		and the decryption shares are simulated as well such that the cipher texts decrypt
		to $c'_{a'_1}, ..., c'_{a'_k}$.
		We also have that, by the ideal functionality of $\elect$, $\set{(a'_\ell, .)}_{\ell \in [k]}$ is a randomly chosen
		ordered subset from $S_\eid$. We can note that, by the correctness of reservoir sampling,
		the output of $\ResevOutputN{\eid}()$ in the protocol is a randomly chosen ordered subset from $S_\eid$.
		We then have that the distribution of the simulator's $\set{(a'_\ell, .)}_{\ell \in [k]} \equiv \set{(a_\ell, .)}_{\ell \in [k]}$
		where $a_\ell$ is the party that won election $\ell$ in the protocol.
		We then have that, by the simulation security of $\registerElect$ (\cref{lemma:regElectSemiHonest}), $c'_{a'_1}, ..., c'_{a'_k} \compInd c_{a_1}, ..., c_{a_k}$ .
	\end{proof}
\end{lemma}

\begin{lemma}[$\reveal$ is simulation secure]
	\begin{proof}
		Note that the simulator can simply run $\reveal$ honestly as the simulator has knowledge of the openings to all of the commitments $c'_j$ used
		and thus has an identical view to that of the real protocol.
	\end{proof}
\end{lemma}

\section{Malicious Adversary Secure Protocol}
\newcommand{\inCTList}{\texttt{Inps}}
\newcommand{\decryptShares}{\texttt{Shares}}

\begin{figure}
	\label{fig:protMal}
	\centering
	\fbox{
		\begin{minipage}{1\textwidth}
			\textbf{The MSLE Protocol} $\pi_{\text{MSLE}}$:
			Initialize $\nBids = 0$. Fix some $k \in \N$ to denote the number of rounds.
			Initialize an empty set of tickets, $R$, an empty lookup of sets of parties in each election, $S$,
			an empty lookup of reservoir sampling data structures $\resSampling$,
			and a set of finished elections $\FinElect$. Initialize an empty lookup of election results, $E$.

			\begin{itemize}
				\item $\init$
				      \begin{itemize}
					      \item Set $n = 0$
					      \item Sample a random $\TFHE$ secret key, public key pair $\TFHESk, \TFHEPk$ and publish $\TFHEPk$.
					      \item Sample some secret $s_{\texttt{TFHE}}$ and publish $\Enc(s_{\texttt{TFHE}})$.
					            This will be the key to the PRF
				      \end{itemize}

				\item $\register$ from party $P_i$
				      \begin{itemize}
					      %  TODO: not within definition of TFHE, have to change up definition :((
					      %  TODO: formalize secure channel?
					      \item If party $P_i$ does not already have a TFHE share, create a TFHE share, $\TFHESk_i$, for $P_i$
					            and send the share over a secure channel to $P_i$.

					      \item $R \gets R \cup \{(i, \nBids)\}$, set $\nBids \gets \nBids + 1$.
				      \end{itemize}
				      % \item Add $\Enc(c_i)$ to $C$.
				      % \item $n \gets n + 1$

				\item $\registerElect(\eid, \Enc(c_j), w)$ from party $P_j$ where $c_j = \comm(s_j)$ for a randomly sampled secret $s_j$.
				Every honest party does the following:
				      \begin{itemize}
					      \item If $\eid \in \FinElect$, then broadcast $\bot$ and do nothing.
								\item TODO: NEED TO CHECK VALID ENCRYPTION
					      \item If $(i, w) \in S_\eid$ or $(i, w) \notin R$, broadcast $\bot$ and do nothing.
					      \item Otherwise, if $\resSampling_\eid \notin \resSampling$, $\resSampling_\eid \gets \ResevInit(k)$
								\item If $\inCTList$ is not initialize, set it to an empty list. Then, set $\inCTList[w] \gets \Enc(c_j)$
					      \item The CRS will be used to run a PRF to get $\Enc(e_j), \Enc(\texttt{coin}_j) = \Enc(\texttt{PRF}(c_j, s_\texttt{TFHE}))$
					      \item $\Enc(c_j)$ will be fed to the encrypted streaming sampler along with randomness via
					            $\ResevInsertN{\eid}(\Enc(c_j), \Enc(e_j), \Enc(\texttt{coin}_j))$.
				      \end{itemize}

				\item $\elect(\eid)$. Each party, $P_i$ does the following:
				      \begin{itemize}
					      \item If $\eid \in \FinElect$, then broadcast $\bot$ and do nothing.
					      \item The encrypted streaming sampler will output a list of $k$ messages via calling $\ResevOutputN{\eid}()$ $k$ times: $\Enc(c_{a_1}), \Enc(c_{a_2}), ..., \Enc(c_{a_k})$.
								\item TODO: NEED TO CHECK ELECTION SET SIZE
								\item Set $n_\bot \gets 0$
					            %  TODO: formal with TFHE decryption shares
								% \item Create a proof using $\proofElem_\eid \gets \NZIKProve(\NZIKCRS, (p_i, \inCTList, \Enc(s_\TFHE)), \TFHESk_i)$
								\item Generate decryption share $p_i$ and set $\decryptShares_\eid \gets \set{p_i}$
								\item Send $(\texttt{prove}, sid, (p_i, \inCTList, \Enc(s_\TFHE)))$ to $\NZIKIdeal$.
								% \item Send $
								\item Upon receiving $\bot$, set $n_\bot \gets n_\bot + 1$.
								\item Upon receiving $(\texttt{proof}, sid, j, (p_j, \inCTList', \Enc(s_\TFHE)'))$ from $\NZIKIdeal$,
								check that $\inCTList = \inCTList$ and that $\Enc(s_\TFHE) = \Enc(s_\TFHE)'$.
								If the equalities hold, set $\decryptShares_\eid \gets \decryptShares_\eid \bigcup \set{p_j}$.
								\item If $|\decryptShares_\eid| \geq t$, use the decryption shares to get $\set{c_{a_1}, ..., c_{a_k}} = \TFHEFinDec(\decryptShares)$.
								And add $E_\eid = \left\{c_{a_1}, ..., c_{a_k}\right\}$ to $E$.
					      % \item Then, at least $t$ parties will submit decryption shares, $p_i = \TFHEPartDec(\Enc(c_{a_1}), ..., \Enc(c_{a_2}))$ to get $c_{a_1}, ..., c_{a_k} = \TFHEFinDec(\{p_i\})$.
								\item If $n_\bot \geq (|\inCTList| - t) + 1$, then abort and output $\bot$.
					      \item TODO: When to abort? At time out, at next election? Etc.
				      \end{itemize}
				\item $\texttt{reveal}(\eid, \ell, \Enc(c'_i))$ from $P_i$
				      \begin{itemize}
					      %  TODO: formal with commitments...
					      \item $P_i$ submits a proof that they know the opening to $c_{a_\ell}$.
					            If this proof verifies, send out $(\texttt{result}, \eid, \ell, i)$ to all parties.
					            Otherwise, send out $(\texttt{rejected}, \eid, \ell, i)$ to all parties.
				      \end{itemize}
			\end{itemize}
		\end{minipage}
	}
	\caption{Description of the MSLE protocol, secure against static malicious adversaries}
	\label{fig:protocolStatisMalMSLE}
\end{figure}

\subsection{Static Malicious Adversary Security}
Consider parties $P_i$ to be corrupted where $i \in C$ and $C \subseteq [n]$ such that.
$|C| < t$.

\begin{lemma}[$\registerElect$ is simulation secure]
	Idea: if $\bot$, just do same	
	If: $j \notin C$, just do same
	If: $j \in C$, then use the NIZK to extract out the commitment from the FHE ciphertext or bot
	Then: S follows protocol
\end{lemma}

\begin{lemma}[$\elect$ is simulation secure]
	Idea: if $\bot$, just do same	
	If: $j \notin C$, just do same
	Output list from streaming sampler using TFHE sim, set to correct sequence (irrespective of advers)
	Ask advers to generate decryption shares for each corrupted party and broadcast proof
	For non-corrupted parties, use TFHE sim to generate decryption shares, simulate proofs
	For corrupted parties, ask advers to generate decryption shares and proofs
	If proofs check, use them, if not discard the decryption shares
\end{lemma}

\begin{lemma}[$\reveal$ is simulation secure]
	% TODO: change decommitment to NZIK? Or find sim sec comm scheme?
	% If we get that it checks out
	If an honest party sends the req, we simulate a commitment opening according to the stored commitment (that we know)
	If corrupted party sends req, pretending to know opening to not their commitment, we say $\bot$ (this is likely as we have the hiding property)
	If corrupted party sends req correctly, we use the de-commitment that they send

\end{lemma}

