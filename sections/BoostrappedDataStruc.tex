\newcommand{\DeQ}{\texttt{Dequeue}}
\newcommand{\DeQAccess}{\texttt{Access}}
\newcommand{\DIPQFr}{\DIPQ_{\texttt{front}}}
\newcommand{\DIPQBack}{\DIPQ_{\texttt{back}}}
\newcommand{\DeQCouner}{\texttt{counter}}
\newcommand{\DeQSize}{\texttt{size}}
\newcommand{\DeQExtractFront}{\texttt{ExtractFront}}
\newcommand{\DeQExtractBack}{\texttt{ExtractBack}}

\section{Building a Dequeue}
Given black box access to a data independent (or oblivious) priority queue,
we can build a data independent (resp. oblivious) double sided queue.
With a double sided queue, we can build a stack and heap as well.

\subsection{Data Independent (Oblivious) Dequeue}
Assume that we have a data independent (resp. oblivious) priority queue, $\DIPQ$.
Then, in \cref{alg:DIQueue}, we show how to build a data independent (resp. oblivious) double sided queue, $\DeQ$.

\begin{algorithm}
	\caption{Data Independent Dequeue ($\DeQ$)}
	\label{alg:DEQueue}
	\begin{algorithmic}[1]
		\Function{$\DIPQInit$}{}
		\State $\DIPQFr \gets \DIPQ.\DIPQInit()$ where $\DIPQFr$ is a min priority queue
		\State $\DIPQBack \gets \DIPQ.\DIPQInit()$ where $\DIPQBack$ is a max priority queue
		\State $\DeQCouner \gets 0$
		\State $\DeQSize \gets 0$
		\EndFunction
		\Function{$\DeQAccess$}{$v, op \in OPS$} \Comment where $OPS = \{\texttt{Ins}, \texttt{ExtrBack}, \texttt{ExtrFront}\}$
			\State $p_{\texttt{front}} = \DeQCouner$ if $op = \texttt{Ins}$ else $\inf$ 
			\State $p_{\texttt{back}} = \DeQCouner$ if $op = \texttt{Ins}$ else $-\inf$
		 	\State $\DIPQBack.\DIPQInsert(p_{\texttt{back}}, v)$ \Comment If $op \neq \texttt{ins}$, then this insert will be ignored
		 	\State $\DIPQFr.\DIPQInsert(p_{\texttt{front}}, v)$ \Comment If $op \neq \texttt{ins}$, then this insert will be ignored

			\State $p_{\texttt{back}}' = -\inf$ if $op = \texttt{\texttt{ExtrBack}}$ and $\inf$ otherwise
			\State $p_{\texttt{front}}' = \inf$ if $op = \texttt{\texttt{ExtrFront}}$ and $-\inf$ otherwise
		 	\State $\DIPQBack.\DIPQInsert(p_{\texttt{back}}', \bot)$ \Comment dummy element which will be removed if $op \neq \texttt{extrBack}$
		 	\State $\DIPQFr.\DIPQInsert(p_{\texttt{front}}', \bot)$ \Comment dummy element which will be removed if $op \neq \texttt{extrFront}$

			\State $\DIPQcounter = \DIPQcounter + 1$ if $op = \texttt{ins}$ and $\DIPQcounter$ otherwise
		 	\State $(p, v)_\texttt{back} \gets \DIPQBack.\texttt{ExtractBack}()$
		 	\State $(p, v)_\texttt{front} \gets \DIPQFr.\DIPQExtract()$

			\State \Return $(p, v)_\texttt{back}, (p, v)_\texttt{front}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\subsection{Correctness}
We assume that the number of insertions is always greater than or equal to the number of extractions.
Thus $\DIPQFr$ and $\DIPQBack$ will never output the same element.

To show correctness, we must show that $\DeQExtractBack$ returns the ``newest'' element in the queue and $\DeQExtractFront$ returns the ``oldest'' element inserted into the queue.
We can do this by simply noting that every inserted item is associated with a unique counter value which increases with every operation.
Thus, extracting from the front of $\DIPQFr$ will always return the oldest element and extracting from the back of $\DIPQBack$ will always return the newest element.

We can also see that when we have a non-insert operation, we are either calling a front or back extract operation.
If we are calling a front extraction, then we insert a dummy element into the back queue which will be removed by the extract operation associated with $(p, v)_{back}$.
If we are calling a back extraction, then we insert a dummy element into the front queue which will be removed by the extract operation.
Thus, we have that calling the ``dummy'' extractions will not change the state of the queue.

\subsection{Obliviousness}
Assuming that $\DIPQ$ is oblivious, we can see that $\DeQ$ is also oblivious as the memory access of $\DeQAccess$ is deterministic.


% TODO: what about synchronization between the two queues?

% we insert a dummy element into the queue which will be removed by the extract operation.
