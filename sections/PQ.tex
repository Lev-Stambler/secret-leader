\section{Data Independent Priority Queue}
Here we introduce a data independent priority queue. We will assume that there are no items in the queue
with equal priority. In practice, we can break ties by adding a unique identifier to each item.

\newcommand{\PQhead}{\texttt{PQ.Head}}
\newcommand{\PQstash}{\texttt{PQ.Stash}}
\newcommand{\PQcounter}{{\texttt{count}}}
\newcommand{\PQpartition}{\mathcal{P}}
\newcommand{\MergeFill}{\texttt{MergeFill}}
\newcommand{\Fill}{\texttt{Fill}}
\newcommand{\sqrtn}{{\sqrt{n}}}
\newcommand{\good}{\mathcal{G}}
\newcommand{\bad}{\mathcal{B}}

\begin{algorithm}
	\caption{MergeFill}
	\begin{algorithmic}[1]
			\State \textbf{Input:} $\PQhead, \PQpartition_\PQcounter$ where $|\PQhead| = \sqrtn$
			\State $e_1, ..., e_\gamma \gets \texttt{sort}(\PQhead, \PQpartition_\PQcounter)$ where $\gamma = |\PQhead| + |\PQpartition_\PQcounter|$
			\State $\PQhead' \gets \{e_1, ..., e_\sqrtn\}$
			\State $\PQpartition_\PQcounter' \gets \{e_{\sqrtn + 1}, ..., e_\gamma\}$
			\State \Return $\PQhead', \PQpartition_\PQcounter'$
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Fill}
	\begin{algorithmic}[1]
			\State \textbf{Input:} $\PQpartition_\PQcounter, \PQstash$
			\State $e_1, ..., e_\gamma \gets \PQpartition_\PQcounter \bigcup \PQstash$ where $\gamma = |\PQpartition_\PQcounter| + |\PQstash|$
			\State $\PQpartition_\PQcounter' \gets \{e_1, ..., e_{\min(\sqrtn, \gamma)}\}$
			\State $\PQstash' \gets \{e_{\min(\gamma, \sqrtn + 1)}, ..., e_\gamma\}$
			\State \Return $\PQpartition_\PQcounter', \PQstash'$
	\end{algorithmic}
\end{algorithm}


	
\begin{algorithm}
	\caption{Data Independent Priority Queue}
	\label{alg:DIQueue}
	\begin{algorithmic}[1]
		\Function{$\PQInit$}{}
		\State $\PQcounter \gets 0$
		\State $\PQhead \gets \PQInit_\sqrtn$
		\State $\PQpartition_1, \cdots, \PQpartition_\sqrtn \gets \emptyset$
		\State $\PQstash \gets \emptyset$
		\EndFunction
		\Function{$\PQInsert$}{$p$}
		\If{$|\PQhead| < \sqrtn$}
		\State $\PQhead \gets \PQInsert(\PQhead, p)$
		\Else
		\State $\PQhead \gets \PQInsert(\PQhead, p)$
		\State $\PQhead, p' \gets \texttt{PQ.Head.ExtractLargest}$ \label{algline:PQExtractIns}
		\State $\PQstash \gets \PQstash \bigcup \{p'\}$
		% \State $\PQcounterIns \gets \PQcounterIns + 1 \mod \sqrtn$
		\EndIf
		\State Call $\texttt{Order}()$ \label{algline:PQOrderIns}
		\EndFunction
		\Function{$\PQExtract$}{}
		\State $\PQhead, p \gets \PQhead\texttt{.Front}$
		\State $p' \gets \texttt{GetLargest}(\PQstash)$
		% \State If $p > p'$, 
		\If{$p > p'$} Remove the front most element, $p$, from $\PQhead$ and set $r = p$.
		\Else \; Remove $p'$ from the stash and set $ r = p'$
		\EndIf
		\State Call $\texttt{Order}()$
		\State \Return $r$
		\EndFunction
		\Function{$\PQOrder$}{}
		\State $\PQpartition_{\PQcounter}, \PQstash \gets \Fill(\PQpartition_\PQcounter, \PQstash)$
		\State $\PQhead, \PQpartition_\PQcounter \gets \MergeFill(\PQhead, \PQpartition_\PQcounter)$
		\State $\PQcounter \gets \PQcounter + 1 \mod \sqrtn$
		\EndFunction
	\end{algorithmic}
\end{algorithm}
% TODO: stash is always empty?? Maybe not...


\subsection{Invariants}
\label{subsec:invariants}
Let $i, j \in \N$ be the total number of insertions and extractions respectively. Note that if $i - j \leq \sqrtn$
and in the prior $i + j$ operations, $i - j$ never exceeded $\sqrtn$, then the priority queue is trivially correct because all elements remain in the head which is itself a priority queue.
Thus, we will assume that at some point in the sequence of insertions and extractions, we had $i - j > \sqrtn$.

Before specifying our invariants, we will add some notation. Let $\good$ ($\good$ for ``good'') be the smallest set of elements in the head. More formally,
$\good$ is the largest subset of $\PQhead$ such that $\forall e \in \PQhead, e \notin \good$, $a < e, \forall a \in \good$. Note that $|\good| \leq \sqrtn$.
Further, let $g$ (the ``good'' element) be the smallest element in $\PQ$ such that $\forall a \in \good, g > a$ and $\forall e \in \PQ \setminus \good, g \leq e$.
Notice that $g$ is not in $\PQhead$.

We will show that the following invariants hold:
\begin{itemize}
	\item The ``good'' element is not in the prior $\sqrtn - |\good|$ iterated over partitions: $g \notin \bigcup_{q \in [\PQcounter - \sqrtn + |\good|, \PQcounter)} \PQpartition_q$
\end{itemize}

\begin{proof}
We proceed by joint induction on $i, j$ where $i - j \leq n$. 
We will first prove the base case where $i - j = \sqrtn + 1$ and $i - j \leq \sqrtn$ for all prior operations.
Note that the last operation had to be an insertion in-order for $i - j$ to increase. Thus, the head contains $\sqrtn$ elements, all of which are smaller than the element evicted by $\texttt{PQ.ExtractLargest}$ (line~\ref{algline:PQExtractIns}) in the insertion operation.
Note that all partitions, $\PQpartition_\alpha$ for $\alpha \in [\sqrtn]$, were empty before this operation and thus the $\PQ.\texttt{order}$
add the element $p'$ evicted from the head to $\PQpartition_\PQcounter$. Thus the good element, $g$ ends up in the first partition.
As $|\good|$ after the insert is $\sqrtn$, we have that the invariants hold trivially.\\


Now for the inductive case, assume that the invariants hold for insertion count $i$ and extraction count $j$. We will show that they hold for $i + 1, j$ and $i, j + 1$.
\paragraph*{Case 1: $i + 1, j$}
\label{proof:case1}
Let $p$ be the inserted element. Note that if $p \leq a$ for some $a \in \good$, then the new ``good'' set, 
$\good'$ has size $|\good'| \gets \min(\sqrtn, |\good| + 1)$. If $p > a$ for all $a \in \good$, then the new ``good'' set, $\good'$ has size $|\good|$ or  $|\good| + 1$ depending on whether $\PQpartition_\PQcounter$ contains $g$ or not.
In either case, we have that $|\good'| \geq |\good|$. If $|\good'| = \sqrtn$, then the invariants hold trivially.

Otherwise, we have that either $|\PQpartition_\PQcounter|$ is $0$ or non-empty. If  $|\PQpartition_\PQcounter| = 0$, then $g \notin \PQpartition'_\PQcounter$ where $\PQpartition'_\PQcounter$ is the updated $\PQpartition_\PQcounter$ after running the insertion.
In the case that $|\PQpartition_\PQcounter| > 0$, note that because we call $\texttt{Order}()$ at the end of insertion (line~\ref{algline:PQOrderIns}) and $|\good| < \sqrtn$,
$\PQhead$ either has an empty slot or an element $\beta$ such that $\beta > g$. Thus after calling $\PQOrder$, we have that $g$ is moved into $\PQhead'$ if $g \in \PQpartition_\PQcounter$
We can then see that $g$ is not in $\PQpartition'_\PQcounter$ and thus the invariants hold
that $g \notin \bigcup_{q \in [\PQcounter + 1 - \sqrtn + |\good|, \PQcounter + 1)} \PQpartition_q$.\\

% To show that invariant 2 holds, 
% TODO: INVARIANT 2!

\paragraph*{Case 2: $i, j + 1$} Note that on an extraction from $\PQhead$, $|\good|$ decreases by 1. Thus for the new ``good'' set, $\good'$, $|\good'| < \sqrtn$.
For the case where $|\good| = \sqrtn$, we must show that $g$ is not in the updated current partition, $\PQpartition'_\PQcounter$ after $\PQOrder$ is called.
This holds because we call $\MergeFill$ on the head and the current partition, $\PQpartition_\PQcounter$. I.e.\ if $\MergeFill$ introduced element $g$
into the head, then $|\good'| = \sqrtn$ and thus the invariants hold trivially. Otherwise, we have that $|\good'| = \sqrtn - 1$ and thus there exists at least one element in the head, $\beta$, such that $\beta > g$.
As $\MergeFill$ guarantees that $\forall e \in \PQpartition'_\PQcounter, e > \beta$, we have that $g$ is not in $\PQpartition'_\PQcounter$ and thus the invariants hold.

Similar to \textbf{case 1}, we either have that $|\PQhead| = \sqrtn$ or has empty slots. In either case, after calling merge sort,
we have that forall $e \in \PQpartition'_\PQcounter$, $e > g$ as if $g  \in \PQpartition_\PQcounter$, then $g$ is moved into the head.
By the inductive hypothesis and the above, we can see that $g \notin \bigcup_{q \in [\PQcounter + 1 - \sqrtn + |\good| - 1, \PQcounter + 1)} \PQpartition_q$. Thus, we then have that invariant holds.\\

% In this case, invariant 2 holds because we increase the number of ``empty'' slots in partition $\PQpartition_\PQcounter$ without increase the size of the stash.
\end{proof}

\subsection{Correctness Proof}
Assuming that the invariants hold in \cref{subsec:invariants}, we will show that the algorithm is correct.
Note that if the total number of inserted elements in the queue is less than $\sqrtn$, correctness holds trivially.
Otherwise, we will show that $\PQpartition_\PQcounter$ is always ``close enough'' to the next ``good'' element.
Whenever $\PQExtract$ is called, we have that $|\good|$ may decrease by 1. If $|\good|$ does decrease by 1,
we still have that the partition containing the next good element, $g$, will be reached in at most $|\good| - 1$ $\PQ$ operations.
So, by the call of $\MergeFill$ in $\PQ.\texttt{Order}()$, we will have that $g$ is in the head or the stash
after $|\good| - 1$ calls. We can then guarantee that the smallest element in the head and stash are at least as small as $g$.
If no insertions were called with $p$ where $p < g$, then $g$ is indeed the smallest element in the priority queue.
Otherwise we will have $p$ in the head and thus $p$ will be the smallest element in the priority queue.
Thus for every call to $\PQExtract$, we can return the smallest item in $\PQ$.


\subsection{Time Complexities}
Fist, we will show that $|\PQstash| \leq \sqrtn$, note that we are guaranteed that the total number of elements in $\PQ$ is at most $n$ and that the capacity of each partition is $\PQpartition_\alpha = \sqrtn$.
Thus, the total capacity of all partitions is $n$ and we then have at least $\sqrtn$ empty slots in the partitions
as the head is guaranteed to contain $\sqrtn$ elements. So, we have that no element which is added to the stash remains
in the stash for more than $\sqrtn$ calls to $\PQ.\texttt{Order}()$ as each call attempts to place an element from the stash into the current partition.
So then, after performing an initial $\sqrtn$ insertions, we have for each subsequent operation, 
we are guaranteed to be able to cumulatively remove $i + j - \sqrtn$ elements from the stash where $i + j$ is the total number of operations.
So, because we can add at most $i$ elements to the stash and remove at least $i + j - \sqrtn$ elements from the stash, we have that $|\PQstash| \leq \sqrtn$.

% \subsection{Invariants}
% \label{subsec:invariants}
% We will show that $\cref{alg:DIQueue}$ is indeed a data independent priority queue by proving a set
% of invariants which directly imply the correctness of the algorithm. First, we will define the notion 
% of a ``good'' set, $\good$, to be a subset of the elements in the head and stash such that, $\forall e \in \PQ, e \notin \good$,
% $g < e, \forall g \in \good$ and $|\good| \leq \sqrtn$.
% Also, let $\alpha$ equal $\PQcounter$ when the first $\texttt{ExtractFront}$ operation is called where $|\PQhead| > \sqrtn$.
% Specifically, we will show the invariants that
% \begin{enumerate}
% 	\item $|\good| - \PQcounter + \alpha \mod \sqrtn \geq \sqrtn$
% 	\item $|\PQstash| \leq \sqrtn$
% 	% TODO: make this invariant **count** specific
% 	\item $\nexists e \in \bigcup_{i \in \{\alpha, ..., \alpha + \sqrtn - |\good|\}} \PQpartition_i$ such that $e < \texttt{sort}(\{e\})_{1, ..., \sqrtn - |\good|}$... Sketch
% 	\begin{enumerate}
% 		\item AFSOC there exists such an element, then note that MergeFill was called here and thus the elements are smaller than that of the head after merge fill.
% 		\item Note that elements in the head never increase with an insertion. At most $\sqrtn - |\good|$ extract fronts are called so that we have a specific size of elements in the head
% 		\item After $\sqrtn$ operations from $\alpha$, you are back at $\alpha$. Note that at this point, MergeFill has been called on all elements of the memory and insertions can only decrease the head.
% 	\end{enumerate}
% \end{enumerate}

% % TODO: lemma 1) insertions only decrease the elements in the head
% % TODO: lemma 2) extract fronts increases one element in the head but this element is smaller than the previous partition
% % OKAY: you insert into the head with extract front, then we have a specific size of element in the head
% % Then, any element which is not "good" in the head can only become smaller. 

% % Invariant: every sqrt n calls, we have only good elements in the head?... No



% % \begin{enumerate}
% % 	\item For $i, j \in [\PQcounterIns, \PQcounterExtr)$ $|\PQpartition_i| = |\PQpartition_j|$ and that
% % 	for $i, j \in [\PQcounterExtr, \PQcounterIns)$ $|\PQpartition_i| = |\PQpartition_j|$.
% % 	\item The sizes of the ``to extract'' counters are one greater than the ``to insert'' counters: i.e.\ $|\PQcounterExtr| = |\PQcounterIns + 1|$
% % 	\item In $\PQhead$, we will refer to the set of ``good'' elements, $\good$, as the set of elements which are the smallest in the whole data structure:
% % 	For $p \in \good$ we have that $\forall i, j \in [\sqrtn], p \leq \{\PQpartition_i\}_j$. We will refer to the set of ``bad'' elements, $\bad$, as the set of elements which are not the smallest in the whole data structure: For $p \in \bad$ we have that $\exists i, j \in [\sqrtn], p > \{\PQpartition_i\}_j$.
% % 	Note that $|\good| + |\bad| = \sqrtn$. We will hold the invariant that $|\good| \geq |\PQcounterIns - \PQcounterExtr|$.
% % \end{enumerate}

% % TODO: prove me
% % \subsection{Correctness}
% % Assuming that invariants hold in \cref{subsec:invariants}, we will show that the algorithm is correct.
% % Note that if the total number of inserted elements in the queue is less than $\sqrtn$, correctness holds trivially.
% % Thus, we will assume that the total number of inserted elements is greater than $\sqrtn$.

% % We will say that an element is ``good'' if it is amongst the $\sqrtn - |\good|$ smallest elements in the whole data structure.
% % The correctness proof will proceed as follows. We will show that $\PQpartition_\PQcounterIns$ is always ``close enough'' to
% % a set of ``good'' elements. Formally, we will show that 
% % \begin{equation}
% % 	\label{eq:condclose}
% % 	\exists e \in \bigcup_{j \in [\PQcounterExtr, \PQcounterExtr + |G|]} \PQpartition_j
% % \end{equation}
% % % TODO: is the amongst correct?
% % such that for $e$ is ``good'' and 
% % \begin{equation}
% % 	\label{eq:condfar}
% % 	\forall j \notin [\PQcounterExtr, \PQcounterExtr + |G|], \nexists e \in \PQpartition_j
% % \end{equation}
% % such that $e$ is ``good''.



% % Let $i \geq \sqrtn$ be the total number of insertions and $j \geq 0$ be the total number of extractions.
% % Note that $\PQhead$ is always full with $\sqrtn$ elements.
% % We will proceed by joint induction on the number of insertions and extractions.

% % For the base case where $\sqrtn = i$ and $j = 0$. We have that $|\good| = \sqrtn$ and thus \cref{eq:condclose} holds trivially.

% % Now we proceed by cases. Assume that \cref{eq:condclose} hold for $i, j$ and we will show that it holds for $i + 1, j$ and $i, j + 1$.

% % \paragraph{Case 1: $i + 1, j$}
% % Let $p$ be the inserted element.
% % Note that $|\bad|, |\good|$ does not decrease as if $p < p_g$ for $p_g \in \good$ then $p$ is inserted into $\PQhead$
% % and $\good$ either increases in size.

% % \paragraph{Case 2: $i, j + 1$}
% % Note that on an extraction from $\PQhead$, $|\good|$ decreases by 1.
% % Let $\alpha$ be the number of ``good'' elements in $\PQpartition_\PQcounterExtr$.
% % If $\alpha = 0$, then, we have that there is a ``good'' element in $\PQpartition_{\PQcounterExtr + 1}, ..., \PQpartition_{\PQcounterExtr + |\good|}$.
% % Thus, the invariant holds.
% % If $\alpha > 0$, then let $\good'$ be the new good set. We have that $|\good'| \gets |\good| - 1 + \alpha$.

% % Then, after the $\MergeFill$ operation, we have that

% % % and $|\bad|$ increases by 1 as we count the empty slot in the head as an element of $\bad$. 
% % % By the inductive hypothesis, we have that there exists $|\bad|$ elements that are ``$|\good|$-close'' to $\PQpartition_\PQcounterExtr$.
% % Let $\alpha$ be the number of ``good'' elements in $\PQpartition_\PQcounterExtr$. Then, after the $\MergeFill$ operation, we have that
% % $|\good'| \gets |\good| + \alpha$ and that we have at least $|\bad| - \alpha$ elements that are ``$|\good|$-close'' to $\PQpartition_\PQcounterExtr$.
% % In the case that $\alpha \geq |\bad| + 1$, then the new size of $\good$ is $\sqrtn$ and thus we have that for all $q \in [\sqrtn]$, $\PQpartition_q$ is ``$|\good|$-close'' to $\PQpartition_\PQcounterExtr$.

% % Otherwise, we have that the new bad set, $\bad'$, has size $|\bad'| \gets |\bad| + 1 - \alpha$
% % and $|\good'| \gets |\good| - 1 + \alpha$. Also, we update $\PQcounterExtr$ to $\PQcounterExtr' \gets \PQcounterExtr + 1$.
% % Note that if we have at least $|\bad| + 1$ ``good'' elements $|\good|$-close to $\PQpartition_\PQcounterExtr$, then we are done.
% % Now, we need to show that we have at least 1 ``good'' element in $\PQpartition_{\PQcounterExtr + |\good| + 1}, \cdots \PQpartition_{\PQcounterExtr + |\good| + \alpha + 1}$.

