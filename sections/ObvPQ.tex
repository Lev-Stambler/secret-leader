\section{Adopting to an Oblivious Priority Queue}
Here we will adopt the above data structure into an oblivious one.

\newcommand{\DIPQOperation}{\texttt{Operation}}
% \newcommand{\DIPQhead}{\texttt{Head}}
% \newcommand{\DIPQstash}{\texttt{Stash}}
% \newcommand{\DIPQcounter}{{\texttt{count}}}
% \newcommand{\DIPQpartition}{\mathcal{P}}
% \newcommand{\MergeFill}{\texttt{MergeFill}}
% \newcommand{\Fill}{\texttt{Fill}}
% \newcommand{\sqrtn}{{\sqrt{n}}}
% \newcommand{\good}{\mathcal{G}}
% \newcommand{\bad}{\mathcal{B}}

\begin{algorithm}
	\caption{$\MergeFill$}
	\begin{algorithmic}[1]
			\State \textbf{Input:} $\DIPQhead, \DIPQpartition_\DIPQcounter$
			\State $e_1, ..., e_\gamma = \texttt{sort}(\DIPQhead, \DIPQpartition_\DIPQcounter)$ where $\gamma = |\DIPQhead| + |\DIPQpartition_\DIPQcounter|$ \Comment Via an oblivious sort
			\State $\DIPQhead = \{e_1, ..., e_{\min\left(\sqrtn, \gamma\right)}\}$
			\State $\DIPQpartition_\DIPQcounter = \{e_{\sqrtn + 1}, ..., e_\gamma\}$
			\State \Return $\DIPQhead', \DIPQpartition_\DIPQcounter$
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{$\Fill$}
	\begin{algorithmic}[1]
			\State \textbf{Input:} $\DIPQpartition_\DIPQcounter, \DIPQstash$
			\State $e_1, ..., e_\gamma = \DIPQpartition_\DIPQcounter \bigcup \DIPQstash$ where $\gamma = |\DIPQpartition_\DIPQcounter| + |\DIPQstash|$
			\State $\DIPQpartition_\DIPQcounter = \{e_1, ..., e_{\min(\sqrtn, \gamma)}\}$
			\State $\DIPQstash = \{e_{\sqrtn + 1}, ..., e_\gamma\}$
			\State \Return $\DIPQpartition_\DIPQcounter', \DIPQstash$
	\end{algorithmic}
\end{algorithm}


	
\begin{algorithm}
	\caption{Oblivious Priority Queue ($\DIPQ$)}
	\label{alg:ObvQueue}
	\begin{algorithmic}[1]
		\Function{$\DIPQInit$}{}
		\State $\DIPQcounter \gets 0$
		\State $\DIPQhead \gets [\inf, ..., \inf]$ where $|\DIPQhead| = \sqrtn$
		\State $\DIPQpartition_0, \cdots, \DIPQpartition_{\sqrtn-1} \gets [\inf, ..., \inf]$ where $|\DIPQpartition_\alpha| = \sqrtn$
		\State $\DIPQstash \gets [\inf, ..., \inf]$ where $|\DIPQstash| = \sqrtn$
		\EndFunction
		\Function{$\DIPQOperation$}{$p, v, op$}
			\State Append $(p, v)$ to $\DIPQhead$
			\State $i, (p', v') = \texttt{GetLargest}(\DIPQhead)$ where $i$ is the index of $(p', v')$ in $\DIPQhead$
			\State $I = 1$ if $p' < p$ else $0$
			\State $\DIPQstash = \DIPQstash :: I \cdot (p, v) + (1 - I) \cdot (p', v')$
			\State $\DIPQhead[i] = I \cdot (p', v') + (1 - I) \cdot (p, v)$
			\State $i, (p_r, v_r) = \texttt{GetSmallest}(\DIPQhead)$
			\State Call $\texttt{Order}()$ \label{algline:ObvPQOrderOp}
			\State \Return $(p_r, v_r)$
		\EndFunction
		\Function{$\DIPQOrder$}{}
			\State $\DIPQpartition_{\DIPQcounter}, \DIPQstash = \Fill(\DIPQpartition_\DIPQcounter, \DIPQstash)$
			\State $\DIPQhead, \DIPQpartition_\DIPQcounter = \MergeFill(\DIPQhead, \DIPQpartition_\DIPQcounter)$
			\State $\DIPQcounter \gets \DIPQcounter + 1 \mod \sqrtn$
		\EndFunction
	\end{algorithmic}
\end{algorithm}
% TODO: stash is always empty?? Maybe not...


\subsection{Correctness}
We can note that we have the same invariants hold as in the data independent case.
We can also see that when we call $\DIPQOperation$ as $\DIPQExtract$ and we set $p = \inf$,
then we the only possible change before the call to $\DIPQOrder$ is that we append an element with priority $\inf$ to the stash.
Because we truncate the stash and the partitions if it grows to over $\sqrtn$ elements (in the call to $\Fill$),
we can see that the ...
% hmmmmm

do not change the state of the queue before calling $\DIPQOrder$ as 
the head evicts the inserted element into the stash.
% TODO: ORDER CHANGE?