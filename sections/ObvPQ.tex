\section{Adopting to an Oblivious Priority Queue}
Here we will adopt the above data structure into an oblivious one.

\newcommand{\DIPQOperation}{\texttt{Access}}
\newcommand{\experiment}{\textbf{Exp}}
\newcommand{\Append}{\texttt{Append}}
	
\begin{algorithm}
	\caption{Oblivious Priority Queue ($\DIPQ$)}
	\label{alg:ObvQueue}
	\begin{algorithmic}[1]
		\Function{$\DIPQInit$}{}
		\State $\DIPQcounter \gets 0$
		% TODO: more formal with $$$$$
		\State $\DIPQhead \gets [(\inf, \$), ..., (\inf, \$)]$ where $|\DIPQhead| = \sqrtn$
		\State $\DIPQpartition_0, \cdots, \DIPQpartition_{\sqrtn-1} \gets [(\inf, \$), ..., (\inf, \$)]$ where $|\DIPQpartition_\alpha| = \sqrtn$
		\State $\DIPQstash \gets [(\inf, \$), ..., (\inf, \$)]$ where $|\DIPQstash| = \sqrtn$
		\EndFunction
		\Function{$\DIPQOperation$}{$p, v, op$}
			\State Append $(p, v)$ to $\DIPQhead$
			\State $i, (p', v') = \texttt{GetLargest}(\DIPQhead)$ where $i$ is the index of $(p', v')$ in $\DIPQhead$
			\State $\texttt{FlagPriority} = 1$ if $p' < p$ else $0$
			\State $\DIPQstash =  \Append(\DIPQstash, \texttt{FlagPriority} \cdot (p, v) + (1 - \texttt{FlagPriority}) \cdot (p', v')$
			\State $\DIPQhead[i] = \texttt{FlagPriority} \cdot (p', v') + (1 - \texttt{FlagPriority}) \cdot (p, v)$
			\State $\texttt{FlagIns} = 1$ if $op = \texttt{Insert}$, otherwise $0$ when $op = \texttt{ExtractFront}$
			\State $\DIPQhead_{ins}, (p_r, v_r)_{ins} =  \DIPQhead, (0, 0)$
			\State $\DIPQhead_{extr}, (p_r, v_r)_{extr} =  \ExtractSmallest(\DIPQhead)$
			\State $\DIPQhead = \texttt{FlagIns} \cdot \DIPQhead_{ins} + (1 - \texttt{FlagIns}) \cdot \Append(\DIPQhead_{extr}, \inf)$
			\State $(p_r, v_r) = \texttt{FlagIns} \cdot (p_r, v_r)_{ins} + (1 - \texttt{FlagIns}) \cdot (p_r, v_r)_{extr}$
			\State Call $\texttt{Order}()$ \label{algline:ObvPQOrderOp}
			\State \Return $(p_r, v_r)$
		\EndFunction
		\Function{$\DIPQOrder$}{}
			\State $\DIPQpartition_{\DIPQcounter}, \DIPQstash = \Fill(\DIPQpartition_\DIPQcounter, \DIPQstash)$
			\State $\DIPQhead, \DIPQpartition_\DIPQcounter = \MergeFill(\DIPQhead, \DIPQpartition_\DIPQcounter)$
			\State $\DIPQcounter \gets \DIPQcounter + 1 \mod \sqrtn$
		\EndFunction
	\end{algorithmic}
\end{algorithm}
% TODO: stash is always empty?? Maybe not...


\subsection{Correctness}
We can note that we have the same invariants hold as in the data independent case.
We can also see that when we call $\DIPQOperation$ as $\DIPQExtract$ and we set $p = \inf$,
then we have that the only possible change before the call to $\DIPQOrder$ is that we append an element with priority $\inf$ to the stash.
Because we truncate the stash and the partitions if it grows to over $\sqrtn$ elements (in the call to $\Fill$),
we can see that the ...
\subsection{Security and Obliviousness}
To show obliviousness we will show that there exists a PPT
adversary $\advers$ and for any $n = \text{poly}(\lambda)$,

\newcommand{\expRealOb}{\experiment_{\DIPQ}^{\text{Real}}(n)}
\newcommand{\expSimOb}{\experiment_{\DIPQ}^{\text{Sim}}(n)}
\begin{equation*}
	\left| \Pr\left[\expRealOb = 1\right] - \Pr\left[\expSimOb = 0\right] \right| < (\lambda)
\end{equation*}
We define $\expRealOb$ and $\expSimOb$ as follows:
- TODO: copy over

\begin{lemma}
	\cref{alg:ObvQueue} is secure and oblivious according to the above definition.
	\begin{proof}
		The proof is rather straightforward, 
		
	\end{proof}
	
\end{lemma}
% hmmmmm
