\section{Adopting to an Oblivious Priority Queue}
Here we will adopt the above data structure into an oblivious one.

\newcommand{\flag}{\texttt{flag}}
\newcommand{\DIPQOperation}{\texttt{Access}}
\newcommand{\experiment}{\textbf{Exp}}
\newcommand{\Append}{\texttt{Append}}
	
\begin{algorithm}
	\caption{Oblivious Priority Queue ($\DIPQ$)}
	\label{alg:ObvQueue}
	\begin{algorithmic}[1]
		\Function{$\DIPQInit$}{}
		\State $\DIPQcounter \gets 0$
		% TODO: more formal with $$$$$
		\State $\DIPQhead \gets [(\inf, \bot), ..., (\inf, \bot)]$ where $|\DIPQhead| = \sqrtn$
		\State $\DIPQpartition_0, \cdots, \DIPQpartition_{\sqrtn-1} \gets [(\inf, \bot), ..., (\inf, \bot)]$ where $|\DIPQpartition_\alpha| = \sqrtn$
		\State $\DIPQstash \gets [(\inf, \bot), ..., (\inf, \bot)]$ where $|\DIPQstash| = \sqrtn$
		\EndFunction
		\Function{$\DIPQOperation$}{$p, v, op \in OPS$} \Comment where $OPS = \{\texttt{Insert}, \texttt{ExtractFront}\}$
			\State Append $(p, v)$ to $\DIPQhead$
			\State $i, (p', v') = \texttt{GetLargest}(\DIPQhead)$ where $i$ is the index of $(p', v')$ in $\DIPQhead$
			\State $\flag_{p} = 1$ if $p' < p$ else $0$
			\State $\DIPQstash =  \Append(\DIPQstash, \flag_p \cdot (p, v) + (1 - \flag_p) \cdot (p', v')$
			\State $\DIPQhead[i] = \flag_p \cdot (p', v') + (1 - \flag_p) \cdot (p, v)$
			\State $\DIPQhead_{ins}, (p_r, v_r)_{ins} =  \DIPQhead, (0, 0)$
			\State $\DIPQhead_{extr}, (p_r, v_r)_{extr} =  \ExtractSmallest(\DIPQhead)$
			\State $\flag_{ins} = 1$ if $op = \texttt{Insert}$, otherwise $0$ when $op = \texttt{ExtractFront}$
			\State $\DIPQhead = \flag_{ins} \cdot \DIPQhead_{ins} + (1 - \flag_{ins}) \cdot \Append(\DIPQhead_{extr}, \inf)$
			\State $(p_r, v_r) = \flag_{ins} \cdot (p_r, v_r)_{ins} + (1 - \flag_{ins}) \cdot (p_r, v_r)_{extr}$
			\State Call $\texttt{Order}()$ \label{algline:ObvPQOrderOp}
			\State \Return $(p_r, v_r)$
		\EndFunction
		\Function{$\DIPQOrder$}{}
			\State $\DIPQpartition_{\DIPQcounter}, \DIPQstash = \Fill(\DIPQpartition_\DIPQcounter, \DIPQstash)$ \Comment See \cref{alg:Fill}
			\State $\DIPQhead, \DIPQpartition_\DIPQcounter = \MergeFill(\DIPQhead, \DIPQpartition_\DIPQcounter)$ \Comment See \cref{alg:MergeFill}
			\State $\DIPQcounter \gets \DIPQcounter + 1 \mod \sqrtn$
		\EndFunction
	\end{algorithmic}
\end{algorithm}
% TODO: stash is always empty?? Maybe not...


\subsection{Correctness}
We can note that we have the same invariants hold as in the data independent case.
We can also see that when we call $\DIPQOperation$ with operation $\DIPQExtract$ where $p = \inf$,
then we have that the only possible change before the call to $\DIPQOrder$ is that we append an element with priority $\inf$ to the stash.
As we are removing the smallest element from the queue but adding back an element with priority $\inf$,
we mantain the size of the queue without changing its correctness.

\subsection{Security and Obliviousness}
We can see that the memory access pattern for $\DIPQOperation$ is deterministic and independent of the input.
We thus have that \cref{alg:ObvQueue} is oblivious.
	