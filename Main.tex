\documentclass[11pt]{article}
\usepackage{Custom}
% \usepackage{algorithmic}
\usepackage{CSTheoryToolkitCMUStyle}
\usepackage{adjustbox}
\usepackage{cryptocode}
\usepackage{cleveref}

\newcommand{\myname}{Authors here}

%%%%% Section-renaming code by egreg
\makeatletter
% we use \prefix@<level> only if it is defined
\renewcommand{\@seccntformat}[1]{%
  \ifcsname prefix@#1\endcsname
    \csname prefix@#1\endcsname
  \else
    \csname the#1\endcsname\quad
  \fi}
% Now we define our homework section prefixes
\makeatother
%%%%%

\begin{document}

\title{Multiple Secret Leaders}

\author{\myname}

\date{\today}
\maketitle

\newcommand{\npar}{n}
\newcommand{\kld}{k}
\newcommand{\comm}{\texttt{comm}}
\newcommand{\Enc}{\texttt{Enc}_{\mathrm{TFHE}}}
\newcommand{\Dec}{\texttt{Dec}_{\mathrm{TFHE}}}
\newcommand{\LS}[1]{\textcolor{red}{LS: #1}}
\newcommand{\compInd}{\stackrel{\mathclap{\normalfont\mbox{c}}}{\equiv}}
\newcommand{\advers}{\mathcal{A}}
\newcommand{\simulator}{\text{Sim}}
\newcommand{\simulatorPQ}{\text{Sim}_\text{PQ}}
\newcommand{\negl}{\texttt{negl}}
\newcommand{\idealMSLE}{\mathcal{F}_{\text{MSLE}}}
\newcommand{\idealStreamSample}{\mathcal{F}_{\text{SAMPLE}}}
\newcommand{\hybrid}[1]{\mathrm{\textbf{Hyb}}_{#1}}
\newcommand{\eid}{{eid}}
\newcommand{\init}{\texttt{initialize}}
\newcommand{\register}{\texttt{register}}
\newcommand{\elect}{\texttt{elect}(\eid, S)}
\newcommand{\electReal}{\texttt{elect}(\eid, S, \Enc(c_{S_1}), ..., \Enc(c_{S_{|S|}}))}
\newcommand{\reveal}{\texttt{reveal}(\eid, \ell)}
\newcommand{\extractMin}{\texttt{ExtractMin}}
\newcommand{\getMin}{\texttt{GetMin}}
\newcommand{\ct}{\texttt{ct}}

\newcommand{\PQInsert}{\texttt{PQ.Insert}}
\newcommand{\PQExtract}{\texttt{PQ.ExtractFront}}
\newcommand{\PQFront}{\texttt{PQ.Front}}
\newcommand{\PQ}{\texttt{PQ}}

\newcommand{\TFHE}{\texttt{TFHE}}
\newcommand{\TFHESetup}{\texttt{TFHE.Setup}}
\newcommand{\TFHEEncrypt}{\texttt{TFHE.Encrypt}}
\newcommand{\TFHEEval}{\texttt{TFHE.Eval}}
\newcommand{\TFHEPartDec}{\texttt{TFHE.PartDec}}
\newcommand{\TFHEFinDec}{\texttt{TFHE.FinDec}}
\newcommand{\TFHEPk}{pk}
\newcommand{\TFHESk}{sk}

\newcommand{\EncPQInsert}{\texttt{EncPQ.Insert}}
\newcommand{\EncPQExtract}{\texttt{EncPQ.ExtractFront}}
\newcommand{\EncPQFront}{\texttt{EncPQ.Front}}
\newcommand{\EncPQ}{\texttt{EncPQ}}

\newcommand{\ResevInsert}{\texttt{Resevoir.Insert}}
\newcommand{\ResevOutput}{\texttt{Resevoir.Output}}

\algrenewcommand\algorithmicrequire{\textbf{Input:}}
\algrenewcommand\algorithmicensure{\textbf{Output:}}

% \begin{abstract}
% \end{abstract}
\section{Some Notation}
\begin{enumerate}
	\item We will have $\npar$ parties
	\item We will have $\kld$ leaders elected
	\item We will have a ``bid'' published by a user $i \in [\npar]$ be denoted as $b_i$
	\item We will denote a commitment as $\comm_i$
	\item We will denote some generic CRHF as $h$
	\item We will say $\Enc$ and $\Dec$ for TFHE encoding and decoding respectively
\end{enumerate}
% \section{Sketching Stuff Out}
% Say we want to elect $\kld$ leaders (maybe with or without repetition) secretly out of $\npar$
% parties, we can run SSLE $\kld$ times but that'd be painful. Let's not do that.

% \subsection{Simple sorting}
% \label{sec:simpleSort}
% A simple approach with runtime (assuming $\kld \leq \npar$) $O(\kld + \npar \log \npar)$
% is to use sorting. At a high level, the idea is to somehow randomly sort the $\npar$ parties 
% then elect the top $\kld$ parties in the sort.
% To do this we can use TFHE in a very similar way to the SSLE paper.

% \begin{algorithm}
% 	\begin{algorithmic}
%     \Require List of bids, $b_1, b_2, ..., b_n$
% 		\State $\alpha \gets \texttt{ROM}(b_1, b_2, ...)$
% 		\For{$i \in [n]$}
% 		\State $b'_i \gets (\Enc(r_i) - \alpha, \Enc(\comm_i))$
% 		\EndFor
% 		\State $\texttt{sorted} = [b'_{j_1}, b'_{j_2}, ...] \gets \texttt{Sort}_{\mathrm{TFHE}}([b'_1, b'_2, ...])$
% 		\State \Return first $k$ elements of $\texttt{sorted}$
% 	\end{algorithmic}
% 	\caption{Simple Sorting Evaluation}
% 	\label{alg:simpleSortEval}
% \end{algorithm}


% \begin{enumerate}
% 	\item \textbf{Setup}: Same exact setup with TFHE in SSLE. Setup TFHE and distribute shares.
% 	      Each party also has some secret $s_i$ and commitment $\comm_i = \comm(s_i)$.
% 	\item \textbf{Publish Bid}: Each party samples $r_i \leftarrow U$ and publish $b_i = (\Enc(r_i), \Enc(\comm_i))$.
% 	\item \textbf{Evaluation}: This is done by one party whom may even be an external party. See \cref{alg:simpleSortEval} for details.
% 	\item \textbf{Decoding}: At least $t$ parties publish their threshold decryptions of the return from the evaluation.
% 	\item \textbf{Proving}: For a party $i$ to prove that they are the selected leader for the $j$th slot, they prove that they know the secret to produce $\comm_i$
% 	      where $\comm_i$ is the decrypted commitment for the $i$th slot.
% \end{enumerate}

% \subsection{Distributed/ Streaming Simple Sorting}
% Assume that $n, k$ are a power of 2. We will keep a lot of the same from sorting
% but now look at selection as a sort of tournament. As a note, security is slightly reduced here as
% a participating party can know that they did not win before the final outcome of the election. I do not know if this matters.

% For completeness, we will write out each step again


% \begin{algorithm}
% 	\caption{$\texttt{PlayGame}$. Homomorphically plays a game to decide which incoming bid ``wins''}
% 	\label{alg:playGame}
% 	\begin{algorithmic}
% 		\Require Point $\alpha \in \F_q$, \\two bids, $b_1 = (\Enc(r_1), \Enc(\comm_1)), (\Enc(r_2), \Enc(\comm_2))$
% 		\Ensure Winning bid. The winning bid should be indistinguishable from a random bid to the non-players
% 		\State $\texttt{closer} \gets \Enc(r_1 - \alpha > r_2 - \alpha)$
% 		\State \Return $\texttt{closer} \cdot b_1 + (1 - \texttt{closer}) \cdot b_2$
% 	\end{algorithmic}
% \end{algorithm}



% \begin{algorithm}
% 	\caption{$\texttt{EvalStream}$. Evaluates a stream of bids as they come in.}
% 	\label{alg:distrEval}
% 	\begin{algorithmic}
% 		% TODO: how to name?
% 		% Name evalStream
% 		\Require $L$, set of $(\texttt{bid}, \texttt{level})$ pairs. New bid and level, $(b, \ell)$. Also, stop level $\ell_{\mathrm{stop}}$
% 		\Ensure New list $L$ with remaining evaluations
		
% 		\If {$\text{there is some for some }b', (b', \ell) \in L$}
% 		\State $\alpha \gets \texttt{ROM}(b, b', \ell)$
% 		\State $\overline{b} \gets \texttt{PlayGame}(b, b')$
% 		\State $L' \gets L \setminus \set{(b', \ell)}$
% 		\If $\ell_{\mathrm{stop}} = \ell - 1$
% 		\State \Return $L \bigcup \set{(\overline{b}, \ell - 1)}$
% 		\Else
% 		\State \Return $\texttt{EvalStream}(L', (\overline{b}, \ell - 1))$
% 		\EndIf
% 		\Else
% 		\State $L' \gets L \bigcup \set{(b, \ell)}$
% 		\State \Return $L'$
% 		\EndIf
% 	\end{algorithmic}
% \end{algorithm}

% \begin{enumerate}
% 	\item \textbf{Setup}: Same exact setup with TFHE in SSLE. Setup TFHE and distribute shares.
% 	      Each party also has some secret $s_i$ and commitment $\comm_i = \comm(s_i)$.
% 	\item \textbf{Publish Bid}: Each party samples $r_i \leftarrow U$ and publish $b_i = (\Enc(r_i), \Enc(\comm_i))$ each tagged with level $\log_2 n + 1$.
% 	\item \textbf{Evaluation}: This step is different than that in the simple sorting version (\cref{sec:simpleSort}).
% 	      Now, we can evaluate in a streaming fashion and even distribute evaluation (though we'll not go into details about the distributed implementation).
% 	      See \cref{alg:distrEval} for the algorithm. The idea is that we keep a list of bids and their levels;
% 	      when a new bid comes in, we greedily remove any bids from the list which we can. We can run \cref{alg:distrEval}
% 	      until there is only one bid left in the list or until all bids up to a level have been processed.
% 	      So, say that we have $k = 4$, we can run the algorithm until we are two levels away (in a tournament tree) from the final level.
% 	      More formally, when we have processed all bids up to level $\ell_{\mathrm{stop}} = \log_2 k + 2$ (and we only have bids at level $\log_2 k + 1$ in the list) we return the list and stop processing.
% 	      When there are $k$ elements in this list, all at level $\log_2 k + 1$, we are done.

% 		    \LS{I may have an off by one error here though I do not think so.}
	      
% 	\item \textbf{Decoding}: At least $t$ parties publish their threshold decryptions of the return from the evaluation
% 	\item \textbf{Proving}: For a party $i$ to prove that they are the selected leader for the $j$th slot, they prove that they know the secret to produce $\comm_i$
% 	      where $\comm_i$ is the decrypted commitment for the $i$th slot
% \end{enumerate}

% \section{Oblivious PQ}
% \input{ObliviousPQ.tex}
% \input{SemiHonest2.tex}
\input{sections/prelims.tex}
\input{sections/TFHEmultielec.tex}


\bibliographystyle{alpha}
\bibliography{bib/ref}

\end{document}

